<?php
/**
 * StatsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Doofinder Management API
 *
 * # Introduction  Doofinder's management API allows you to perform some of the administrative tasks you can do on your search engines using the doofinder control panel, directly from your code.  # Basics  ## Endpoint  All requests should be done with `https` protocol in our API location.  `https://{search_zone}-api.doofinder.com`  where `{search_zone}` depends on your location, is the geographic zone your search engine is located at. i.e.: eu1. Also, indicates which host to use in your API calls.  ## Authentication  We provide two methods of authentication for our API. In any of these you need a management API key that you could obtain in our [management control panel](https://www.doofinder.com/admin).  You can generate it in your user account -> API Keys.  Example of a generated API Key: `eu1-ab46030xza33960aac71a10248489b6c26172f07`  ### API Token  You can authenticate with the previous API key in header as a Token. The correct way to authenticate is to send a HTTP Header with the name `Authorization` and the value `Token <API Key>`  For example, for the key shown above:  `Authorization: Token eu1-ab46030xza33960aac71a10248489b6c26172f07`  ### JWT Token (Draft)  Also you can authenticate with a [JSON Web Token](https://jwt.io) generating JWT keys with your API Key. To authenticate using JWT you need to send a HTTP Header with the name `Authorization` and the value `Bearer <JWT token>`.  For example, with the key shown above:  `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoidGVzdCIsImlhdCI6MTUxNjIzOTAyMn0.QX_3HF-T2-vlvzGDbAzZyc1Cd-J9qROSes3bxlgB4uk`  ## Conventions  Along most of the code samples you will find placeholders for some common variable values. They are:  - `{hashid}`: The search engine's unique id. i.e.: d8fdeab7fce96a19d3fc7b0ca7a1e98b - `{index}`: When storing items, they're always stored under a certain \"index\". i.e.: product. - `{token}`: Your personal authentication token obtained in the control panel. - `{uid}`: The Id of a Doofinder User  # Objects  ## Search Engines  A Search Engine is a set of multiple Indices, and some options to configure them. It must contain at least one indice.  A Search Engine can be uniquely identified by the parameter called `hashid`.  A Search Engine can be processed, which means the process of reading the data from the Data Sources (usually an url), indexing the data in a temporary index and finally build the index ready for use.  ## Indices  An Index is a collection of Items, the same way a Search Engine is a collection of Indices. It has options that define the schema used for Items, Data Sources that define where to get the data, and some searching options.  Each Index may also have one temporary index. A temporary index shares the same options of its main index. There are operations to manage temporary indices like create, delete, reindex, etc. The usual flow for a temporary index is create one, index items on it and replace the main index with the temporary one. This way you can reindex your whole data having zero downtime of the search service.  ## Data Sources  A Data Source defines a source of items for indexing. There are many kinds but they are basically a location for taking items for indexing and the most common is just an url with a file. These are the sources that are read when calling a Search Engine processing. An Index does not need a Data Source if you index the items directly using the API.  ## Items  Items are the objects stored in an Index, and the ones returned after executing a search. Items may have an schema (a collection of fields) depending on their Index preset. This way a `product` item has price, category, etc.
 *
 * OpenAPI spec version: 2.0
 * Contact: support@doofinder.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.18
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * StatsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class StatsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation bannersClicks
     *
     * Get the total amount of clicks over banners.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StatsBannersResult
     */
    public function bannersClicks($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        list($response) = $this->bannersClicksWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format);
        return $response;
    }

    /**
     * Operation bannersClicksWithHttpInfo
     *
     * Get the total amount of clicks over banners.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StatsBannersResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function bannersClicksWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsBannersResult';
        $request = $this->bannersClicksRequest($from, $to, $hashid, $id, $tz, $device, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatsBannersResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bannersClicksAsync
     *
     * Get the total amount of clicks over banners.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersClicksAsync($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        return $this->bannersClicksAsyncWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bannersClicksAsyncWithHttpInfo
     *
     * Get the total amount of clicks over banners.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersClicksAsyncWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsBannersResult';
        $request = $this->bannersClicksRequest($from, $to, $hashid, $id, $tz, $device, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bannersClicks'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function bannersClicksRequest($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling bannersClicks'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling bannersClicks'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling bannersClicks'
            );
        }

        $resourcePath = '/api/v2/stats/banners/clicks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bannersDisplay
     *
     * Gets how many times a banner has been shown.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StatsBannersResult
     */
    public function bannersDisplay($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        list($response) = $this->bannersDisplayWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format);
        return $response;
    }

    /**
     * Operation bannersDisplayWithHttpInfo
     *
     * Gets how many times a banner has been shown.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StatsBannersResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function bannersDisplayWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsBannersResult';
        $request = $this->bannersDisplayRequest($from, $to, $hashid, $id, $tz, $device, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatsBannersResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bannersDisplayAsync
     *
     * Gets how many times a banner has been shown.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersDisplayAsync($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        return $this->bannersDisplayAsyncWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bannersDisplayAsyncWithHttpInfo
     *
     * Gets how many times a banner has been shown.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersDisplayAsyncWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsBannersResult';
        $request = $this->bannersDisplayRequest($from, $to, $hashid, $id, $tz, $device, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bannersDisplay'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the banner. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function bannersDisplayRequest($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling bannersDisplay'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling bannersDisplay'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling bannersDisplay'
            );
        }

        $resourcePath = '/api/v2/stats/banners/displays';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkoutsByDate
     *
     * Get the checkouts by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StatsTimeResult
     */
    public function checkoutsByDate($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->checkoutsByDateWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format);
        return $response;
    }

    /**
     * Operation checkoutsByDateWithHttpInfo
     *
     * Get the checkouts by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StatsTimeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkoutsByDateWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsTimeResult';
        $request = $this->checkoutsByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatsTimeResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkoutsByDateAsync
     *
     * Get the checkouts by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkoutsByDateAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        return $this->checkoutsByDateAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkoutsByDateAsyncWithHttpInfo
     *
     * Get the checkouts by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkoutsByDateAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsTimeResult';
        $request = $this->checkoutsByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkoutsByDate'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function checkoutsByDateRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling checkoutsByDate'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling checkoutsByDate'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling checkoutsByDate'
            );
        }

        $resourcePath = '/api/v2/stats/checkouts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clicksByDate
     *
     * Get the clicks by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StatsTimeResult
     */
    public function clicksByDate($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null)
    {
        list($response) = $this->clicksByDateWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id);
        return $response;
    }

    /**
     * Operation clicksByDateWithHttpInfo
     *
     * Get the clicks by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StatsTimeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function clicksByDateWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null)
    {
        $returnType = '\Swagger\Client\Model\StatsTimeResult';
        $request = $this->clicksByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatsTimeResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clicksByDateAsync
     *
     * Get the clicks by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByDateAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null)
    {
        return $this->clicksByDateAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clicksByDateAsyncWithHttpInfo
     *
     * Get the clicks by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByDateAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null)
    {
        $returnType = '\Swagger\Client\Model\StatsTimeResult';
        $request = $this->clicksByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clicksByDate'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clicksByDateRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling clicksByDate'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling clicksByDate'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling clicksByDate'
            );
        }

        $resourcePath = '/api/v2/stats/clicks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($custom_results_id !== null) {
            $queryParams['custom_results_id'] = ObjectSerializer::toQueryValue($custom_results_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clicksByQuery
     *
     * Get the products clicked given a certain query term.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse200
     */
    public function clicksByQuery($from, $to, $hashid, $query, $tz = '+00:00', $device = null, $format = 'json')
    {
        list($response) = $this->clicksByQueryWithHttpInfo($from, $to, $hashid, $query, $tz, $device, $format);
        return $response;
    }

    /**
     * Operation clicksByQueryWithHttpInfo
     *
     * Get the products clicked given a certain query term.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function clicksByQueryWithHttpInfo($from, $to, $hashid, $query, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\InlineResponse200';
        $request = $this->clicksByQueryRequest($from, $to, $hashid, $query, $tz, $device, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clicksByQueryAsync
     *
     * Get the products clicked given a certain query term.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByQueryAsync($from, $to, $hashid, $query, $tz = '+00:00', $device = null, $format = 'json')
    {
        return $this->clicksByQueryAsyncWithHttpInfo($from, $to, $hashid, $query, $tz, $device, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clicksByQueryAsyncWithHttpInfo
     *
     * Get the products clicked given a certain query term.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByQueryAsyncWithHttpInfo($from, $to, $hashid, $query, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\InlineResponse200';
        $request = $this->clicksByQueryRequest($from, $to, $hashid, $query, $tz, $device, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clicksByQuery'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clicksByQueryRequest($from, $to, $hashid, $query, $tz = '+00:00', $device = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling clicksByQuery'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling clicksByQuery'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling clicksByQuery'
            );
        }
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling clicksByQuery'
            );
        }

        $resourcePath = '/api/v2/stats/clicks/by-query/{query}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }

        // path params
        if ($query !== null) {
            $resourcePath = str_replace(
                '{' . 'query' . '}',
                ObjectSerializer::toPathValue($query),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clicksTop
     *
     * Get the most common clicks.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query Search query term. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2001
     */
    public function clicksTop($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query = null)
    {
        list($response) = $this->clicksTopWithHttpInfo($from, $to, $hashid, $tz, $device, $format, $query);
        return $response;
    }

    /**
     * Operation clicksTopWithHttpInfo
     *
     * Get the most common clicks.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query Search query term. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function clicksTopWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->clicksTopRequest($from, $to, $hashid, $tz, $device, $format, $query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clicksTopAsync
     *
     * Get the most common clicks.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query Search query term. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksTopAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query = null)
    {
        return $this->clicksTopAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $format, $query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clicksTopAsyncWithHttpInfo
     *
     * Get the most common clicks.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query Search query term. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksTopAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->clicksTopRequest($from, $to, $hashid, $tz, $device, $format, $query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clicksTop'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query Search query term. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clicksTopRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling clicksTop'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling clicksTop'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling clicksTop'
            );
        }

        $resourcePath = '/api/v2/stats/clicks/top';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation initsByDate
     *
     * Get the search sessions by dates.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StatsTimeResult
     */
    public function initsByDate($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->initsByDateWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format);
        return $response;
    }

    /**
     * Operation initsByDateWithHttpInfo
     *
     * Get the search sessions by dates.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StatsTimeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function initsByDateWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsTimeResult';
        $request = $this->initsByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatsTimeResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation initsByDateAsync
     *
     * Get the search sessions by dates.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initsByDateAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        return $this->initsByDateAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation initsByDateAsyncWithHttpInfo
     *
     * Get the search sessions by dates.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initsByDateAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsTimeResult';
        $request = $this->initsByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'initsByDate'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function initsByDateRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling initsByDate'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling initsByDate'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling initsByDate'
            );
        }

        $resourcePath = '/api/v2/stats/inits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redirects
     *
     * Get the total amount of redirections done.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the redirection. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StatsRedirectsResult
     */
    public function redirects($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        list($response) = $this->redirectsWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format);
        return $response;
    }

    /**
     * Operation redirectsWithHttpInfo
     *
     * Get the total amount of redirections done.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the redirection. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StatsRedirectsResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function redirectsWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsRedirectsResult';
        $request = $this->redirectsRequest($from, $to, $hashid, $id, $tz, $device, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatsRedirectsResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation redirectsAsync
     *
     * Get the total amount of redirections done.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the redirection. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redirectsAsync($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        return $this->redirectsAsyncWithHttpInfo($from, $to, $hashid, $id, $tz, $device, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redirectsAsyncWithHttpInfo
     *
     * Get the total amount of redirections done.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the redirection. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redirectsAsyncWithHttpInfo($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsRedirectsResult';
        $request = $this->redirectsRequest($from, $to, $hashid, $id, $tz, $device, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redirects'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  int $id Unique id of the redirection. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function redirectsRequest($from, $to, $hashid, $id = null, $tz = '+00:00', $device = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling redirects'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling redirects'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling redirects'
            );
        }

        $resourcePath = '/api/v2/stats/redirects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchesByClick
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StatsTopSearchesResult
     */
    public function searchesByClick($from, $to, $hashid, $dfid, $tz = '+00:00', $device = null, $format = 'json')
    {
        list($response) = $this->searchesByClickWithHttpInfo($from, $to, $hashid, $dfid, $tz, $device, $format);
        return $response;
    }

    /**
     * Operation searchesByClickWithHttpInfo
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StatsTopSearchesResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchesByClickWithHttpInfo($from, $to, $hashid, $dfid, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsTopSearchesResult';
        $request = $this->searchesByClickRequest($from, $to, $hashid, $dfid, $tz, $device, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatsTopSearchesResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchesByClickAsync
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByClickAsync($from, $to, $hashid, $dfid, $tz = '+00:00', $device = null, $format = 'json')
    {
        return $this->searchesByClickAsyncWithHttpInfo($from, $to, $hashid, $dfid, $tz, $device, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchesByClickAsyncWithHttpInfo
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByClickAsyncWithHttpInfo($from, $to, $hashid, $dfid, $tz = '+00:00', $device = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsTopSearchesResult';
        $request = $this->searchesByClickRequest($from, $to, $hashid, $dfid, $tz, $device, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchesByClick'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchesByClickRequest($from, $to, $hashid, $dfid, $tz = '+00:00', $device = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling searchesByClick'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling searchesByClick'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling searchesByClick'
            );
        }
        // verify the required parameter 'dfid' is set
        if ($dfid === null || (is_array($dfid) && count($dfid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dfid when calling searchesByClick'
            );
        }

        $resourcePath = '/api/v2/stats/clicks/{dfid}/searches/top';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }

        // path params
        if ($dfid !== null) {
            $resourcePath = str_replace(
                '{' . 'dfid' . '}',
                ObjectSerializer::toPathValue($dfid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchesByDate
     *
     * Get the searches by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StatsTimeResult
     */
    public function searchesByDate($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null, $query_name = null, $source = null, $total_hits = null)
    {
        list($response) = $this->searchesByDateWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id, $query_name, $source, $total_hits);
        return $response;
    }

    /**
     * Operation searchesByDateWithHttpInfo
     *
     * Get the searches by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StatsTimeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchesByDateWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null, $query_name = null, $source = null, $total_hits = null)
    {
        $returnType = '\Swagger\Client\Model\StatsTimeResult';
        $request = $this->searchesByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id, $query_name, $source, $total_hits);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatsTimeResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchesByDateAsync
     *
     * Get the searches by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByDateAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null, $query_name = null, $source = null, $total_hits = null)
    {
        return $this->searchesByDateAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id, $query_name, $source, $total_hits)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchesByDateAsyncWithHttpInfo
     *
     * Get the searches by dates
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByDateAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null, $query_name = null, $source = null, $total_hits = null)
    {
        $returnType = '\Swagger\Client\Model\StatsTimeResult';
        $request = $this->searchesByDateRequest($from, $to, $hashid, $tz, $device, $interval, $format, $custom_results_id, $query_name, $source, $total_hits);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchesByDate'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $interval Time interval for aggregations. (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $custom_results_id Filter by some custom result. (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchesByDateRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $interval = '1d', $format = 'json', $custom_results_id = null, $query_name = null, $source = null, $total_hits = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling searchesByDate'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling searchesByDate'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling searchesByDate'
            );
        }

        $resourcePath = '/api/v2/stats/searches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($custom_results_id !== null) {
            $queryParams['custom_results_id'] = ObjectSerializer::toQueryValue($custom_results_id);
        }
        // query params
        if ($query_name !== null) {
            $queryParams['query_name'] = ObjectSerializer::toQueryValue($query_name);
        }
        // query params
        if ($source !== null) {
            $queryParams['source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($total_hits !== null) {
            $queryParams['total_hits'] = ObjectSerializer::toQueryValue($total_hits);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchesTop
     *
     * Get the most common searches.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     * @param  object $exclude Exclude filters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StatsTopSearchesResult
     */
    public function searchesTop($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query_name = null, $total_hits = null, $exclude = null)
    {
        list($response) = $this->searchesTopWithHttpInfo($from, $to, $hashid, $tz, $device, $format, $query_name, $total_hits, $exclude);
        return $response;
    }

    /**
     * Operation searchesTopWithHttpInfo
     *
     * Get the most common searches.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     * @param  object $exclude Exclude filters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StatsTopSearchesResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchesTopWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query_name = null, $total_hits = null, $exclude = null)
    {
        $returnType = '\Swagger\Client\Model\StatsTopSearchesResult';
        $request = $this->searchesTopRequest($from, $to, $hashid, $tz, $device, $format, $query_name, $total_hits, $exclude);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatsTopSearchesResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchesTopAsync
     *
     * Get the most common searches.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     * @param  object $exclude Exclude filters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesTopAsync($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query_name = null, $total_hits = null, $exclude = null)
    {
        return $this->searchesTopAsyncWithHttpInfo($from, $to, $hashid, $tz, $device, $format, $query_name, $total_hits, $exclude)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchesTopAsyncWithHttpInfo
     *
     * Get the most common searches.
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     * @param  object $exclude Exclude filters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesTopAsyncWithHttpInfo($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query_name = null, $total_hits = null, $exclude = null)
    {
        $returnType = '\Swagger\Client\Model\StatsTopSearchesResult';
        $request = $this->searchesTopRequest($from, $to, $hashid, $tz, $device, $format, $query_name, $total_hits, $exclude);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchesTop'
     *
     * @param  string $from Start date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of UNIX timestamp or YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. Time zones may be specified as an ISO 8601 UTC offset (e.g. +01:00 or -08:00). (optional, default to +00:00)
     * @param  string $device Filter by kind of device. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by the number of search results. (optional)
     * @param  object $exclude Exclude filters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchesTopRequest($from, $to, $hashid, $tz = '+00:00', $device = null, $format = 'json', $query_name = null, $total_hits = null, $exclude = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling searchesTop'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling searchesTop'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling searchesTop'
            );
        }

        $resourcePath = '/api/v2/stats/searches/top';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($query_name !== null) {
            $queryParams['query_name'] = ObjectSerializer::toQueryValue($query_name);
        }
        // query params
        if ($total_hits !== null) {
            $queryParams['total_hits'] = ObjectSerializer::toQueryValue($total_hits);
        }
        // query params
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usage
     *
     * Get the search engines usage.
     *
     * @param  string $from Start date of the interval in the format of YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StatsTimeResult
     */
    public function usage($from, $to, $hashid, $type = null, $format = 'json')
    {
        list($response) = $this->usageWithHttpInfo($from, $to, $hashid, $type, $format);
        return $response;
    }

    /**
     * Operation usageWithHttpInfo
     *
     * Get the search engines usage.
     *
     * @param  string $from Start date of the interval in the format of YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StatsTimeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function usageWithHttpInfo($from, $to, $hashid, $type = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsTimeResult';
        $request = $this->usageRequest($from, $to, $hashid, $type, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatsTimeResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usageAsync
     *
     * Get the search engines usage.
     *
     * @param  string $from Start date of the interval in the format of YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usageAsync($from, $to, $hashid, $type = null, $format = 'json')
    {
        return $this->usageAsyncWithHttpInfo($from, $to, $hashid, $type, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usageAsyncWithHttpInfo
     *
     * Get the search engines usage.
     *
     * @param  string $from Start date of the interval in the format of YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usageAsyncWithHttpInfo($from, $to, $hashid, $type = null, $format = 'json')
    {
        $returnType = '\Swagger\Client\Model\StatsTimeResult';
        $request = $this->usageRequest($from, $to, $hashid, $type, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usage'
     *
     * @param  string $from Start date of the interval in the format of YYYYMMDD. (required)
     * @param  string $to End date of the interval in the format of YYYYMMDD. (required)
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usageRequest($from, $to, $hashid, $type = null, $format = 'json')
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling usage'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling usage'
            );
        }
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling usage'
            );
        }

        $resourcePath = '/api/v2/stats/usage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
