<?php
/**
 * StatsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Doofinder Management API
 *
 * # Introduction Doofinder's management API allows you to perform the same administrative tasks you can do on your search engines using the doofinder control panel, directly from your code.  You could found here our legacy [Management API V1](https://www.doofinder.com/support/developer/api/management-api).  # Basics ## Endpoint All requests should be done with `https` protocol in our api location.  `https://{search_zone}-api.doofinder.com`  where `{search_zone}` depends on your location, is the geographic zone your search engine is located at. i.e.: eu1. Also, indicates which host to use in your API calls.  ## Authentication  We provide two methods of authentication for our API. In any of theese you need a management api key that you could obtain in our [management control panel](https://www.doofinder.com/admin).  You can generate it in your user account -> Api Keys.  Example of the generated API Key: `eu1-ab46030xza33960aac71a10248489b6c26172f07`  ### API Token You could authenticate with the previous API key in header as a Token. The correct way to authenticate is to send a HTTP Header with the name `Authorization` and the value `Token <API Key>`  For example, for the key shown above:  `Authorization: Token eu1-ab46030xza33960aac71a10248489b6c26172f07`  ### JWT Token (Draft) Also you could authenticate with a JSON Web Token generating jwt keys with your API Key. To authenticate using JWT you need to send a HTTP Header with the name `Authorization` and the value `Bearer <JWT token>`.  For example, with the key shown above:  `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoidGVzdCIsImlhdCI6MTUxNjIzOTAyMn0.QX_3HF-T2-vlvzGDbAzZyc1Cd-J9qROSes3bxlgB4uk`  ## Conventions Along most of the code samples you will find placeholders for some common variable values. They are:  - `{hashid}`: The search engine's unique id. i.e.: d8fdeab7fce96a19d3fc7b0ca7a1e98b - `{index}`: When storing items, they're always stored under a certain \"index\". i.e.: product. - `{token}`: Your personal authentication token obtained in the control panel. - `{uid}`: The Id of a Doofinder User
 *
 * OpenAPI spec version: 2.0
 * Contact: support@doofinder.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.18
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * StatsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class StatsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation bannersClicks
     *
     * Get the total amount of clicks banners have got
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the banner. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function bannersClicks($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->bannersClicksWithHttpInfo($hashid, $to, $from, $tz, $id, $device, $interval, $format);
        return $response;
    }

    /**
     * Operation bannersClicksWithHttpInfo
     *
     * Get the total amount of clicks banners have got
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the banner. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function bannersClicksWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->bannersClicksRequest($hashid, $to, $from, $tz, $id, $device, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bannersClicksAsync
     *
     * Get the total amount of clicks banners have got
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the banner. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersClicksAsync($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        return $this->bannersClicksAsyncWithHttpInfo($hashid, $to, $from, $tz, $id, $device, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bannersClicksAsyncWithHttpInfo
     *
     * Get the total amount of clicks banners have got
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the banner. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersClicksAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->bannersClicksRequest($hashid, $to, $from, $tz, $id, $device, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bannersClicks'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the banner. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function bannersClicksRequest($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling bannersClicks'
            );
        }

        $resourcePath = '/api/v2/stats/banners/clicks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bannersDisplay
     *
     * Get the total amount of displays banners have got
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the banner. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function bannersDisplay($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->bannersDisplayWithHttpInfo($hashid, $to, $from, $tz, $id, $device, $interval, $format);
        return $response;
    }

    /**
     * Operation bannersDisplayWithHttpInfo
     *
     * Get the total amount of displays banners have got
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the banner. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function bannersDisplayWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->bannersDisplayRequest($hashid, $to, $from, $tz, $id, $device, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bannersDisplayAsync
     *
     * Get the total amount of displays banners have got
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the banner. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersDisplayAsync($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        return $this->bannersDisplayAsyncWithHttpInfo($hashid, $to, $from, $tz, $id, $device, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bannersDisplayAsyncWithHttpInfo
     *
     * Get the total amount of displays banners have got
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the banner. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bannersDisplayAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->bannersDisplayRequest($hashid, $to, $from, $tz, $id, $device, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bannersDisplay'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the banner. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function bannersDisplayRequest($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling bannersDisplay'
            );
        }

        $resourcePath = '/api/v2/stats/banners/displays';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkoutsByDate
     *
     * Get the checkouts by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function checkoutsByDate($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->checkoutsByDateWithHttpInfo($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format);
        return $response;
    }

    /**
     * Operation checkoutsByDateWithHttpInfo
     *
     * Get the checkouts by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkoutsByDateWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->checkoutsByDateRequest($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkoutsByDateAsync
     *
     * Get the checkouts by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkoutsByDateAsync($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        return $this->checkoutsByDateAsyncWithHttpInfo($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkoutsByDateAsyncWithHttpInfo
     *
     * Get the checkouts by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkoutsByDateAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->checkoutsByDateRequest($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkoutsByDate'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function checkoutsByDateRequest($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling checkoutsByDate'
            );
        }

        $resourcePath = '/api/v2/stats/checkouts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($custom_results_id !== null) {
            $queryParams['custom_results_id'] = ObjectSerializer::toQueryValue($custom_results_id);
        }
        // query params
        if ($query_name !== null) {
            $queryParams['query_name'] = ObjectSerializer::toQueryValue($query_name);
        }
        // query params
        if ($total_hits !== null) {
            $queryParams['total_hits'] = ObjectSerializer::toQueryValue($total_hits);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clicksByDate
     *
     * Get the clicks by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function clicksByDate($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->clicksByDateWithHttpInfo($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format);
        return $response;
    }

    /**
     * Operation clicksByDateWithHttpInfo
     *
     * Get the clicks by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function clicksByDateWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->clicksByDateRequest($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clicksByDateAsync
     *
     * Get the clicks by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByDateAsync($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        return $this->clicksByDateAsyncWithHttpInfo($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clicksByDateAsyncWithHttpInfo
     *
     * Get the clicks by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByDateAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->clicksByDateRequest($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clicksByDate'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clicksByDateRequest($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling clicksByDate'
            );
        }

        $resourcePath = '/api/v2/stats/clicks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($custom_results_id !== null) {
            $queryParams['custom_results_id'] = ObjectSerializer::toQueryValue($custom_results_id);
        }
        // query params
        if ($query_name !== null) {
            $queryParams['query_name'] = ObjectSerializer::toQueryValue($query_name);
        }
        // query params
        if ($total_hits !== null) {
            $queryParams['total_hits'] = ObjectSerializer::toQueryValue($total_hits);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clicksByQuery
     *
     * Get the products clicked given a certain query
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function clicksByQuery($hashid, $query, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->clicksByQueryWithHttpInfo($hashid, $query, $to, $from, $tz, $device, $interval, $format);
        return $response;
    }

    /**
     * Operation clicksByQueryWithHttpInfo
     *
     * Get the products clicked given a certain query
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function clicksByQueryWithHttpInfo($hashid, $query, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->clicksByQueryRequest($hashid, $query, $to, $from, $tz, $device, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clicksByQueryAsync
     *
     * Get the products clicked given a certain query
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByQueryAsync($hashid, $query, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $format = 'json')
    {
        return $this->clicksByQueryAsyncWithHttpInfo($hashid, $query, $to, $from, $tz, $device, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clicksByQueryAsyncWithHttpInfo
     *
     * Get the products clicked given a certain query
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksByQueryAsyncWithHttpInfo($hashid, $query, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->clicksByQueryRequest($hashid, $query, $to, $from, $tz, $device, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clicksByQuery'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $query Search query term (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clicksByQueryRequest($hashid, $query, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling clicksByQuery'
            );
        }
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling clicksByQuery'
            );
        }

        $resourcePath = '/api/v2/stats/clicks/by-query/{query}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }

        // path params
        if ($query !== null) {
            $resourcePath = str_replace(
                '{' . 'query' . '}',
                ObjectSerializer::toPathValue($query),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clicksTop
     *
     * Get the most common clicks
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $query Filter by query done. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function clicksTop($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $query = null, $format = 'json')
    {
        list($response) = $this->clicksTopWithHttpInfo($hashid, $to, $from, $tz, $device, $interval, $query, $format);
        return $response;
    }

    /**
     * Operation clicksTopWithHttpInfo
     *
     * Get the most common clicks
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $query Filter by query done. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function clicksTopWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $query = null, $format = 'json')
    {
        $returnType = 'object';
        $request = $this->clicksTopRequest($hashid, $to, $from, $tz, $device, $interval, $query, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clicksTopAsync
     *
     * Get the most common clicks
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $query Filter by query done. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksTopAsync($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $query = null, $format = 'json')
    {
        return $this->clicksTopAsyncWithHttpInfo($hashid, $to, $from, $tz, $device, $interval, $query, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clicksTopAsyncWithHttpInfo
     *
     * Get the most common clicks
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $query Filter by query done. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clicksTopAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $query = null, $format = 'json')
    {
        $returnType = 'object';
        $request = $this->clicksTopRequest($hashid, $to, $from, $tz, $device, $interval, $query, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clicksTop'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $query Filter by query done. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clicksTopRequest($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $query = null, $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling clicksTop'
            );
        }

        $resourcePath = '/api/v2/stats/clicks/top';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation initsByDate
     *
     * Get the sessions started by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function initsByDate($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->initsByDateWithHttpInfo($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format);
        return $response;
    }

    /**
     * Operation initsByDateWithHttpInfo
     *
     * Get the sessions started by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function initsByDateWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->initsByDateRequest($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation initsByDateAsync
     *
     * Get the sessions started by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initsByDateAsync($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        return $this->initsByDateAsyncWithHttpInfo($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation initsByDateAsyncWithHttpInfo
     *
     * Get the sessions started by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initsByDateAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->initsByDateRequest($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $total_hits, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'initsByDate'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function initsByDateRequest($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling initsByDate'
            );
        }

        $resourcePath = '/api/v2/stats/inits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($custom_results_id !== null) {
            $queryParams['custom_results_id'] = ObjectSerializer::toQueryValue($custom_results_id);
        }
        // query params
        if ($query_name !== null) {
            $queryParams['query_name'] = ObjectSerializer::toQueryValue($query_name);
        }
        // query params
        if ($total_hits !== null) {
            $queryParams['total_hits'] = ObjectSerializer::toQueryValue($total_hits);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation metrics
     *
     * Get the search engines usage.
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function metrics($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->metricsWithHttpInfo($hashid, $to, $from, $tz, $device, $interval, $format);
        return $response;
    }

    /**
     * Operation metricsWithHttpInfo
     *
     * Get the search engines usage.
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function metricsWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->metricsRequest($hashid, $to, $from, $tz, $device, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation metricsAsync
     *
     * Get the search engines usage.
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function metricsAsync($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $format = 'json')
    {
        return $this->metricsAsyncWithHttpInfo($hashid, $to, $from, $tz, $device, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation metricsAsyncWithHttpInfo
     *
     * Get the search engines usage.
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function metricsAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->metricsRequest($hashid, $to, $from, $tz, $device, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'metrics'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function metricsRequest($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling metrics'
            );
        }

        $resourcePath = '/api/v2/stats/metrics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redirects
     *
     * Get the total amount of redirects done
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the redirection. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function redirects($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->redirectsWithHttpInfo($hashid, $to, $from, $tz, $id, $device, $interval, $format);
        return $response;
    }

    /**
     * Operation redirectsWithHttpInfo
     *
     * Get the total amount of redirects done
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the redirection. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function redirectsWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->redirectsRequest($hashid, $to, $from, $tz, $id, $device, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation redirectsAsync
     *
     * Get the total amount of redirects done
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the redirection. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redirectsAsync($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        return $this->redirectsAsyncWithHttpInfo($hashid, $to, $from, $tz, $id, $device, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redirectsAsyncWithHttpInfo
     *
     * Get the total amount of redirects done
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the redirection. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redirectsAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->redirectsRequest($hashid, $to, $from, $tz, $id, $device, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redirects'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  int $id ID of the redirection. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function redirectsRequest($hashid, $to = null, $from = null, $tz = null, $id = null, $device = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling redirects'
            );
        }

        $resourcePath = '/api/v2/stats/redirects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchesByClick
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchesByClick($hashid, $dfid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $total_hits = null, $format = 'json')
    {
        list($response) = $this->searchesByClickWithHttpInfo($hashid, $dfid, $to, $from, $tz, $device, $interval, $total_hits, $format);
        return $response;
    }

    /**
     * Operation searchesByClickWithHttpInfo
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchesByClickWithHttpInfo($hashid, $dfid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $total_hits = null, $format = 'json')
    {
        $returnType = 'object';
        $request = $this->searchesByClickRequest($hashid, $dfid, $to, $from, $tz, $device, $interval, $total_hits, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchesByClickAsync
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByClickAsync($hashid, $dfid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $total_hits = null, $format = 'json')
    {
        return $this->searchesByClickAsyncWithHttpInfo($hashid, $dfid, $to, $from, $tz, $device, $interval, $total_hits, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchesByClickAsyncWithHttpInfo
     *
     * Get the top searches that got a product clicked
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByClickAsyncWithHttpInfo($hashid, $dfid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $total_hits = null, $format = 'json')
    {
        $returnType = 'object';
        $request = $this->searchesByClickRequest($hashid, $dfid, $to, $from, $tz, $device, $interval, $total_hits, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchesByClick'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $dfid Doofinder ID to filter by (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchesByClickRequest($hashid, $dfid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $total_hits = null, $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling searchesByClick'
            );
        }
        // verify the required parameter 'dfid' is set
        if ($dfid === null || (is_array($dfid) && count($dfid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dfid when calling searchesByClick'
            );
        }

        $resourcePath = '/api/v2/stats/clicks/{dfid}/searches/top';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($total_hits !== null) {
            $queryParams['total_hits'] = ObjectSerializer::toQueryValue($total_hits);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }

        // path params
        if ($dfid !== null) {
            $resourcePath = str_replace(
                '{' . 'dfid' . '}',
                ObjectSerializer::toPathValue($dfid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchesByDate
     *
     * Get the searches by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchesByDate($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $source = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        list($response) = $this->searchesByDateWithHttpInfo($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $source, $total_hits, $interval, $format);
        return $response;
    }

    /**
     * Operation searchesByDateWithHttpInfo
     *
     * Get the searches by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchesByDateWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $source = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->searchesByDateRequest($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $source, $total_hits, $interval, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchesByDateAsync
     *
     * Get the searches by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByDateAsync($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $source = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        return $this->searchesByDateAsyncWithHttpInfo($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $source, $total_hits, $interval, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchesByDateAsyncWithHttpInfo
     *
     * Get the searches by dates
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesByDateAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $source = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        $returnType = 'object';
        $request = $this->searchesByDateRequest($hashid, $to, $from, $tz, $device, $custom_results_id, $query_name, $source, $total_hits, $interval, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchesByDate'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $custom_results_id Filter by custom results (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  string $source Filter by search source. (optional)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchesByDateRequest($hashid, $to = null, $from = null, $tz = null, $device = null, $custom_results_id = null, $query_name = null, $source = null, $total_hits = null, $interval = '1d', $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling searchesByDate'
            );
        }

        $resourcePath = '/api/v2/stats/searches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($custom_results_id !== null) {
            $queryParams['custom_results_id'] = ObjectSerializer::toQueryValue($custom_results_id);
        }
        // query params
        if ($query_name !== null) {
            $queryParams['query_name'] = ObjectSerializer::toQueryValue($query_name);
        }
        // query params
        if ($source !== null) {
            $queryParams['source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($total_hits !== null) {
            $queryParams['total_hits'] = ObjectSerializer::toQueryValue($total_hits);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchesTop
     *
     * Get the most common searches
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  object $exclude Exclude filters (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchesTop($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $total_hits = null, $query_name = null, $exclude = null, $format = 'json')
    {
        list($response) = $this->searchesTopWithHttpInfo($hashid, $to, $from, $tz, $device, $interval, $total_hits, $query_name, $exclude, $format);
        return $response;
    }

    /**
     * Operation searchesTopWithHttpInfo
     *
     * Get the most common searches
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  object $exclude Exclude filters (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchesTopWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $total_hits = null, $query_name = null, $exclude = null, $format = 'json')
    {
        $returnType = 'object';
        $request = $this->searchesTopRequest($hashid, $to, $from, $tz, $device, $interval, $total_hits, $query_name, $exclude, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchesTopAsync
     *
     * Get the most common searches
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  object $exclude Exclude filters (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesTopAsync($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $total_hits = null, $query_name = null, $exclude = null, $format = 'json')
    {
        return $this->searchesTopAsyncWithHttpInfo($hashid, $to, $from, $tz, $device, $interval, $total_hits, $query_name, $exclude, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchesTopAsyncWithHttpInfo
     *
     * Get the most common searches
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  object $exclude Exclude filters (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchesTopAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $total_hits = null, $query_name = null, $exclude = null, $format = 'json')
    {
        $returnType = 'object';
        $request = $this->searchesTopRequest($hashid, $to, $from, $tz, $device, $interval, $total_hits, $query_name, $exclude, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchesTop'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  int $total_hits Filter by total hits (optional)
     * @param  string $query_name Type of query to filter by (optional)
     * @param  object $exclude Exclude filters (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchesTopRequest($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $total_hits = null, $query_name = null, $exclude = null, $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling searchesTop'
            );
        }

        $resourcePath = '/api/v2/stats/searches/top';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($total_hits !== null) {
            $queryParams['total_hits'] = ObjectSerializer::toQueryValue($total_hits);
        }
        // query params
        if ($query_name !== null) {
            $queryParams['query_name'] = ObjectSerializer::toQueryValue($query_name);
        }
        // query params
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usage
     *
     * Get the search engines usage.
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function usage($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $type = null, $format = 'json')
    {
        list($response) = $this->usageWithHttpInfo($hashid, $to, $from, $tz, $device, $interval, $type, $format);
        return $response;
    }

    /**
     * Operation usageWithHttpInfo
     *
     * Get the search engines usage.
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function usageWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $type = null, $format = 'json')
    {
        $returnType = 'object';
        $request = $this->usageRequest($hashid, $to, $from, $tz, $device, $interval, $type, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usageAsync
     *
     * Get the search engines usage.
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usageAsync($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $type = null, $format = 'json')
    {
        return $this->usageAsyncWithHttpInfo($hashid, $to, $from, $tz, $device, $interval, $type, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usageAsyncWithHttpInfo
     *
     * Get the search engines usage.
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usageAsyncWithHttpInfo($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $type = null, $format = 'json')
    {
        $returnType = 'object';
        $request = $this->usageRequest($hashid, $to, $from, $tz, $device, $interval, $type, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usage'
     *
     * @param  string $hashid HashID of the search engine to query or a list in the format [hashid1,hashid2,...] (required)
     * @param  string $to Date end of the interval in the format of UNIX timestamp or YYYYMMDD. Today, by default. (optional)
     * @param  string $from Date start of the interval in the format of UNIX timestamp or YYYYMMDD. By default, 10 days from current date. (optional)
     * @param  string $tz Timezone for the given dates, by default assumes UTC. (optional)
     * @param  string $device Device filter, by default is all (optional)
     * @param  string $interval Time interval for aggregations (optional, default to 1d)
     * @param  string $type Filter by the given usage type. (optional)
     * @param  string $format Indicates which response format should be used (optional, default to json)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usageRequest($hashid, $to = null, $from = null, $tz = null, $device = null, $interval = '1d', $type = null, $format = 'json')
    {
        // verify the required parameter 'hashid' is set
        if ($hashid === null || (is_array($hashid) && count($hashid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashid when calling usage'
            );
        }

        $resourcePath = '/api/v2/stats/usage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($tz !== null) {
            $queryParams['tz'] = ObjectSerializer::toQueryValue($tz);
        }
        // query params
        if ($hashid !== null) {
            $queryParams['hashid'] = ObjectSerializer::toQueryValue($hashid);
        }
        // query params
        if ($device !== null) {
            $queryParams['device'] = ObjectSerializer::toQueryValue($device);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
